#!/usr/bin/perl

BEGIN {
    use File::Basename;
    my $d = dirname $0;
    if (-l $0) {
        my $l = dirname readlink $0;
        $bin_dir = $l;
        $bin_dir = "$d/$bin_dir" unless $l =~ m|^/|;
    }
    else {
        $bin_dir = $d;
    }
    push @INC, $bin_dir;
    push @INC, "$bin_dir/../../..";
}

use 5.10.0;

use Time::HiRes 'sleep';

use strict;
use warnings;

use threads;
use threads::shared;

use File::stat;
use Getopt::Std;

use Fish::Youtube::Get;
use Fish::Youtube::Utility;

my $TMP = '/tmp';

my $MP = 'mp';
my $AUTO_PERC = .1;

sub error;
sub war;

$| = 1;

my $G = 'Fish::Youtube::Get';

my @TYPES = $G->types;
my @QUALITY = $G->quality;

@TYPES = (@TYPES[0..2], 'tmp', @TYPES[3..$#TYPES]);

my $USAGE;
{
    my $f = join '/', @TYPES;
    my $q = join '/', @QUALITY;
    $USAGE = "Usage: $0 [-v] [-q quiet] [-t tmpdir] [-f to force] [-o output-file] [-d dir, ignored if -o is abs] [-q $q] [-F $f] [-T if not terminal] [-p to provide prompt if preferred qual/type not available; otherwise try fallbacks] [-P always prompt (ignore -p)] youtube-url ";
}

our $opt_T;
our $opt_d;
our $opt_o;
our $opt_f;
our $opt_q;
our $opt_t;
our $opt_Q;
our $opt_F;
our $opt_p;
our $opt_P;
our $opt_v;

getopts('Q:F:fo:kvt:qd:TpPv');

disable_colors() if $opt_T;

my $url = shift or error "$USAGE";
$Fish::Youtube::Utility::LOG_LEVEL = 1;

my $p_qual = $opt_Q // 'medium';
my $p_type = $opt_F // 'mp4';

my $get = Fish::Youtube::Get->new(
    $opt_t ? (tmp => $opt_t) : (),
    $opt_o ? (out_file => $opt_o) : (),
    $opt_d ? (dir => $opt_d) : (),
    force => $opt_f ? 1 : 0,
    #quiet => $opt_q ? 1 : 0,

    url => $url,
);

my $avail = $get->get_avail or error "Can't get info.";

if ($opt_v) {
    say datadump $avail;
}

my $type;
my $quality;

# always prompt
if ($opt_P) {
    ($quality, $type) = prompt();
}
else {
    
    ($quality, $type) = $get->check($p_qual, $p_type);

    # couldn't get preferred
    if (!$type || !$quality) {
        if ($opt_p) {
            # got preferred qual but not type
            if ($quality) {
                D 'Got preferred quality, prompting for type.';
                $type = prompt($quality);
            }
            else {
                D "Prompting for quality and type.";
                ($quality, $type) = prompt();
            }
        }
        else {
            if ($quality) {
                D 'Got preferred quality but not type.';
                $type = $get->fallback($p_type, $p_qual, $quality);
            }
            else {
                D "Getting fallback quality and type.";
                ($quality, $type) = $get->fallback($p_type, $p_qual);
            }
        }
    }

    else { 
        #ok
    }
}

$quality and $type or die;

D 'Getting', 'quality', $quality, 'type', $type;

$get->set($quality, $type) or die;

my $of = $get->out_file;

D 'Output file', $of;

if (my ($ext) = ($of =~ /\.([^\.]+)$/)) {
    if ($type !~ m|^video/ (x-)? $ext |x) {
        war "Warning: type is", Y $type, "but extension is", R $ext;
    }
}

my $size = $get->get_size;

if (open my $fh, ">$TMP/.yt-file-$$") {
    say $fh $of;
    say $fh $size;
}

async { progress($size, $of) }->detach;

$get->get;

sub progress {
    my ($size, $of) = @_;

    my $ap_started = 0;
    my $first = 1;
    while ( 1 ) {
        $first ? $first = 0 : sleep .5 ;

        -e $of or next;

        my $cur = stat($of)->size;

        if (!$ap_started and $cur / $size >= $AUTO_PERC) {
            $ap_started = 1;
            sys qq, $MP "$of" ,;
        }

        my $a = nice_bytes_join ($cur);
        my $b = nice_bytes_join ($size);

        my $s = sprintf "%s / %s", BB $a, Y $b;

        print "\r" . " " x 40 . "" x 40;
        printf $s;
    }
}

exit;

sub error {
    my @s = @_;
    die join ' ', @s, "\n";
}

sub war {
    my @s = @_;
    warn join ' ', @s, "\n";
}

sub make_menu {
    my @opts = @_;
    my $n = scalar @opts;
    my $width = length $n - 1;
    my $i = 0;
    say sprintf("%${width}d. %s", ++$i, $_) for @opts;
    my $res;
    local $\ = undef;
    while (!$res) {
        print "> ";
        my $a = <STDIN>;
        next unless $a;
        chomp $a;
        $a =~ s/\s//g;
        next if $a =~ /\D/;
        next if $a < 1;
        $res = $opts[$a - 1];
    }
    return $res;
}

sub prompt {
    my $qual = shift;

    my @qual = grep { defined $avail->{$_} } @QUALITY;

    if (! $qual) {
        $qual = make_menu(@qual);
    }

    D 'got qual', $qual;
    my %h = hash $avail->{$qual};
    my $t = make_menu(keys %h);

    #$get_url = $h{$t};
    #D 'got url', $get_url;

    return ($qual, $t);
}

sub END {
    say '';
}

