#!/usr/bin/perl

package main;

our $bin_dir;

BEGIN {
    use File::Basename;
    my $d = dirname $0;
    if (-l $0) {
        my $l = dirname readlink $0;
        $bin_dir = $l;
        $bin_dir = "$d/$bin_dir" unless $l =~ m|^/|;
    }
    else {
        $bin_dir = $d;
    }
    push @INC, $bin_dir;
    push @INC, "$bin_dir/../../..";
}

use 5.10.0;

use strict;
use warnings;

use threads;
use threads::shared;

use Gtk2 qw/ -init -threads-init /;

use Time::HiRes 'sleep';

use POSIX qw/ WNOHANG setsid /;
use Proc::SyncExec qw/ sync_exec sync_popen_noshell /;
use Proc::ProcessTable;

use Getopt::Std;
use File::Temp;

use Fish::Youtube::Utility;
use Fish::Youtube::Gtk;
use Fish::Youtube::History;
use Fish::Youtube::Get;

use constant THREADING_DOWNLOADS => 0;

use if THREADING_DOWNLOADS, 'Fish::Youtube::DownloadThreads';

sub error;
sub war;
sub DT;

#%

my $TMP_TMPL = 'fishtubeXXXX';

# force END
$SIG{KILL} = $SIG{INT} = sub { exit };

my @Tmp_dirs;

my $TMP = '/tmp';

my $MOVIE_PLAYER = 'mplayer';
# use [ and ] for changing speed of movie without chipmunking the sound. 
# and allow resizing.
my $MOVIE_PLAYER_OPTS = '-af scaletempo -zoom';

our ($opt_h, $opt_p, $opt_d, $opt_o);
our $opt_Z;
getopts('hp:do:Z');

THREADING_DOWNLOADS and $Fish::Youtube::DownloadThreads::Debug_threads = $opt_Z;

my $debug;
if ($opt_d) {
    $debug = 1;
    $Fish::Youtube::Utility::LOG_LEVEL++;
}

$| = 1;

my $USAGE = "Usage: $0 [-p firefox-profile] [-d to debug] [-o output_dir]";

$opt_h and error $USAGE;

## gtk erases vars in threads sometimes
#eval {
#sub Debug_threads { $Debug_threads }
#};

my $Profile_dir;
my $Output_dir;

my $g = 'Fish::Youtube::Gtk';

my $profile_ask;
{
    my %profiles = get_profiles();
    if ($opt_p) {
        my $p = $profiles{$opt_p} or error "No profile named", Y $opt_p;
        set_profile_dir($p);
    }
    else {
        my @v = values %profiles;
        if (@v == 1) {
            set_profile_dir(shift @v);
        }
        else {
            $profile_ask = \%profiles;
        }
    }
}

my $output_dir_ask;
if ($opt_o) {
    check_output_dir($opt_o);
    set_output_dir($opt_o);
}
else {
    $output_dir_ask = 1;
}

sub get_profiles {

    my %profiles;

    my $h = $ENV{HOME} or error "HOME env variable not set and no profile dir given.";
    my $d = "$ENV{HOME}/.mozilla/firefox";
    -d $d or error "Dir", Y $d, "doesn't exist and no profile dir given.";
    -r $d or error "Dir", Y $d, "not readable and no profile dir given.";
    my $f = "$d/profiles.ini";
    -e $f or error "File", Y $f, "doesn't exist and no profile dir given.";
    -r $f or error "File", Y $f, "not readable and no profile dir given.";

    #[General]
    #StartWithLastProfile=1
    #
    #[Profile0]
    #Name=default
    #IsRelative=1
    #Path=qrnjdznh.default
    #Default=1
    #
    #[Profile1]
    #Name=blah
    #IsRelative=1
    #Path=xdrjtfpq.blah
    #
    #[Profile2]
    #Name=blah2
    #IsRelative=0
    #Path=/tmp

    my $fh = safeopen $f;
    my $in = 0;
    my @cur;
    my $first = 1;

    local $/ = undef;
    my $ini = <$fh>;

    my @s = split / ^ ( \[ Profile \d+ \] ) $/mx, $ini;
    shift @s;
    my $i = -1;
    my $p;
    for (@s) {
        # header
        if (not ++$i % 2) {
            $p = $_;
        }
        # body
        else {
            my ($name) = /Name=(.+)/;
            my ($path) = /Path=(.+)/;
            $name or error "Couldn't get name for profile", Y $p;
            $path or error "Couldn't get dir for profile", Y $p;
            $profiles{$name} = "$d/$path";
        }
    }

    return %profiles;
}

sub set_profile_dir {
    my ($pd) = @_;
    $Profile_dir = $pd;
}

timeout( 1000, sub { poll_movies() } );


# Output_dir can be undef
$g->init($Output_dir, { profile_ask => $profile_ask });

exit;

# # #

sub poll_movies {
    $Profile_dir or return 1;

    my $hist = Fish::Youtube::History->new(
        num_movies => 15,
        # can be undef
        profile_dir => $Profile_dir,
    );

    $hist->update;
    my $m = $hist->movies;

    # no undefined element
    if (@$m and not grep { not defined } @$m) {
        $g->set_buf($m);
    }

    return 1;
}

sub error {
    my @s = @_;
    my $e = join ' ', @s, "\n";
    if (Fish::Youtube::Gtk->inited) {
        Fish::Youtube::Gtk::err($e);
    }
    else {
        die $e;
    }
}

sub war {
    my @s = @_;
    warn join ' ', @s, "\n";
}

sub make_tmp_dir {
    my $d = File::Temp->newdir( $TMP_TMPL, DIR => $TMP, CLEANUP => 1 );
    # so it doesn't go out of scope
    push @Tmp_dirs, $d;
    $d->dirname;
}

# want prompting for qual and type
# still in event loop -- no enter/exit necessary
sub start_download_sync {

    my $did = shift // die;

    # used?
    my $mid = shift // die;

    my $url = shift or die;
    my $output_dir = shift or die;

    # one or both are '', meaning prompt
    my $prefq = shift // die;
    my $preft = shift // die;

    # is_tolerant
    # is always 1 if the corresponding pref is ''.
    my $itaq = shift // die;
    my $itat = shift // die;
    $itaq = 1 unless $prefq;
    $itat = 1 unless $preft;

    my $msg = {
        output_dir => $output_dir,

        did => $did,
        url => $url,
        prefq => $prefq,
        preft => $preft,
        itaq => $itaq,
        itat => $itat,

        async => 0,
    };

    return _start_download($did, $msg);
}

sub start_download_async {
    my $did = shift // die;

    #used ?
    my $mid = shift // die;

    my $url = shift or die;

    my $output_dir = shift or die;

    my $prefq = shift // die;
    my $preft = shift // die;
    # is_tolerant
    my $itaq = shift // die;
    my $itat = shift // die;

    D2 'starting async.';

    my $msg = {
        # note that we don't know output_file; Get sets it.

        output_dir => $output_dir,

        did => $did,
        url => $url,
        prefq => $prefq,
        preft => $preft,
        itaq => $itaq,
        itat => $itat,

        async => 1,
    };

    return _start_download($did, $msg);
}

sub _start_download {

    my ($did, $msg) = @_;

    my $tmp_dir = main::make_tmp_dir();

    $msg->{tmp} = $tmp_dir;

    my $do_async = $msg->{async};

    my %dl_tracker = ();

    my %md = ();
    $dl_tracker{metadata} = \%md;

    if ($do_async) {
        my $output_dir = $msg->{output_dir} or warn, return;
        my $url = $msg->{url} or warn, return;
        my $tmp = $msg->{tmp} or warn, return;

        # as text, not id
        my $prefq = $msg->{prefq};
        defined $prefq or warn, return;
        my $preft = $msg->{preft};
        defined $preft or warn, return;

        # is_tolerant
        my $itaq = $msg->{itaq};
        defined $itaq or warn, return;
        my $itat = $msg->{itat};
        defined $itat or warn, return;

        my @init = (
            mode => 'eventloop',

            dir => $output_dir,
            url => $url,

            tmp => $tmp,

            # gui should take care of prompting for overwrite
            force => 1,

            debug => $debug,

            preferred_qual => $prefq,
            preferred_type => $preft,
            is_tolerant_about_quality => $itaq,
            is_tolerant_about_type => $itat,
        );

        my $get = Fish::Youtube::Get->new(@init);
        #my $ok = $get->get(\$Cancel_by_did{$did});
my $cancel;

        my $done = '';
        my $ok = $get->get(\$done, \$cancel);
        if (!$ok) {
            $dl_tracker{errstr} = $get->errstr;
            $dl_tracker{status} = 'error';
        }
        else {
            $dl_tracker{status} = 'started';
            $dl_tracker{done_r} = \$done;

            $md{size} = $get->size or warn;
            $md{of} = $get->out_file or warn;
        }
    }
    else {

warn 'not implemented';
my $response;
my $qo;
my $qi;
my $of;
        # note that errstr has to found out another way if async.
        my $e;
        $e = $response->{error} and warn ($response->{errstr} // ''), return;

        my @quals = list $response->{quals};

        my $qual = Fish::Youtube::Gtk::list_choice_dialog(\@quals, "Choose quality", {allow_cancel => 1});

        if ($qual) {
            #$qo->enqueue( { qual => $qual } );
        }
        else {
            #$qo->enqueue( { cancel => 1 });
            return -1;
        }

        # types for this qual
        #$response = $qi->dequeue or warn, return;

        my @types = list $response->{types} or warn, return;

        my $type = Fish::Youtube::Gtk::list_choice_dialog(\@types, "Choose format", {allow_cancel => 1});

        if (! $type) {
            $dl_tracker{status} = 'cancelled';
        }
        # else ok
    }

    #if (-r $of) {
    #my $ok = Fish::Youtube::Gtk::replace_file_dialog($of);
         
    return \%dl_tracker;
}



sub process_running {
    my ($pid) = @_;
    my $t = Proc::ProcessTable->new->table;
    my @children = grep { 
        $_->{pid} == $pid 
    } @$t;
    return @children ? 1 : 0;
}

sub timeout {
    my ($time, $sub) = @_;
    Glib::Timeout->add($time, $sub );
}

sub watch_movie {
    my ($file) = @_;
    if ( ! -e $file ) {
        $g->err("File '$file' doesn't exist, can't watch.");
        return;
    }
    if ( ! sys_ok qq, which $MOVIE_PLAYER , ) {
        $g->status("Movie player '$MOVIE_PLAYER' doesn't exist.");
        return;
    }

    my $o = $MOVIE_PLAYER_OPTS // '';

    my $pid = sync_exec qq, $MOVIE_PLAYER >/dev/null 2>&1 $o "$file" ,;

    #if (my $pid = fork) {
    #    D 'child pid', $pid;
    #}
    #else {
    #    # not necessary
    #    setsid();
    #    # mplayer spawns a new shell and this ends up 'defunct', causing
    #    # segfault on close?
    #    exec qq, $MOVIE_PLAYER >/dev/null 2>&1 $o "$file" ,;
    #}
}

sub set_output_dir {
    my ($od) = @_;
    $Output_dir = $od or die;
    #D $od;
}

sub check_output_dir {
    my ($od) = @_;
    my $ok = 1;
    $ok = 0, error "Output dir", Y $od, "doesn't exist" unless -d $od;
    $ok = 0, error "Output dir", Y $od, "not writeable" unless -w $od;

    # error won't die if gui already up
    return $ok;
}

sub sanitize_filename {
    my $tr = shift;
    $$tr =~ s/^\s+//;
    $$tr =~ s/\s+$//;
    $$tr =~ s/[\n:!\*<>\`\$]//g;
    
    $$tr =~ s|/|-|g;
    $$tr =~ s|\\|-|g;
    $$tr =~ s/"/'/g;
}

sub DT {
    $Fish::Youtube::DownloadThreads::Debug_threads and say "main: ", D_QUIET @_;
}

END {
    # die is ok in end
    for my $d (@Tmp_dirs) {
        # fishtubeXXXX
        my $t = $TMP_TMPL;
        my $num_x = 0;
        $num_x++ while $t =~ s/X$//;
        die unless $d =~ m| / $t .{$num_x} $|ix;
        die if $d =~ m| ^ /usr |x;
        die if $d =~ m| ^ /home/ [^/]+ /? $ |x;
        sys qq, rm -rf "$d" ,;
    }
}

