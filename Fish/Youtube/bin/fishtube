#!/usr/bin/perl

package main;

our $bin_dir;

BEGIN {
    use File::Basename;
    my $d = dirname $0;
    if (-l $0) {
        my $l = dirname readlink $0;
        $bin_dir = $l;
        $bin_dir = "$d/$bin_dir" unless $l =~ m|^/|;
    }
    else {
        $bin_dir = $d;
    }
    push @INC, $bin_dir;
    push @INC, "$bin_dir/../../..";
}

use 5.10.0;

use strict;
use warnings;

use threads;
use threads::shared;

# as early as possible to keep copies smaller
use Fish::Youtube::DownloadThreads;

use Gtk2;

use Time::HiRes 'sleep';

use POSIX qw/ WNOHANG setsid /;
use Proc::SyncExec qw/ sync_exec sync_popen_noshell /;
use Proc::ProcessTable;

use Getopt::Std;
use File::Temp;

use Fish::Youtube::Utility;
use Fish::Youtube::Gtk;
use Fish::Youtube::History;
use Fish::Youtube::Get;


sub error;
sub war;

#%

my @Tmp_dirs;


my $TMP = '/tmp';

my $MOVIE_PLAYER = 'mplayer';
# use [ and ] for changing speed of movie without chipmunking the sound. 
# and allow resizing.
my $MOVIE_PLAYER_OPTS = '-af scaletempo -zoom';

our ($opt_h, $opt_p, $opt_d, $opt_o);
getopts('hp:do:');

$opt_d and $Fish::Youtube::Utility::LOG_LEVEL++;

$| = 1;

my $USAGE = "Usage: $0 [-p firefox-profile] [-d to debug] [-o output_dir]";

$opt_h and error $USAGE;

                state $III = 0;
my $Profile_dir;
my $Output_dir;

my $g = 'Fish::Youtube::Gtk';

my $profile_ask;
{
    my %profiles = get_profiles();
    if ($opt_p) {
        my $p = $profiles{$opt_p} or error "No profile named", Y $opt_p;
        set_profile_dir($p);
    }
    else {
        my @v = values %profiles;
        if (@v == 1) {
            set_profile_dir(shift @v);
        }
        else {
            $profile_ask = \%profiles;
        }
    }
}

my $output_dir_ask;
if ($opt_o) {
    check_output_dir($opt_o);
    set_output_dir($opt_o);
}
else {
    $output_dir_ask = 1;
}

sub get_profiles {

    my %profiles;

    my $h = $ENV{HOME} or error "HOME env variable not set and no profile dir given.";
    my $d = "$ENV{HOME}/.mozilla/firefox";
    -d $d or error "Dir", Y $d, "doesn't exist and no profile dir given.";
    -r $d or error "Dir", Y $d, "not readable and no profile dir given.";
    my $f = "$d/profiles.ini";
    -e $f or error "File", Y $f, "doesn't exist and no profile dir given.";
    -r $f or error "File", Y $f, "not readable and no profile dir given.";

    #[General]
    #StartWithLastProfile=1
    #
    #[Profile0]
    #Name=default
    #IsRelative=1
    #Path=qrnjdznh.default
    #Default=1
    #
    #[Profile1]
    #Name=blah
    #IsRelative=1
    #Path=xdrjtfpq.blah
    #
    #[Profile2]
    #Name=blah2
    #IsRelative=0
    #Path=/tmp

    my $fh = safeopen $f;
    my $in = 0;
    my @cur;
    my $first = 1;

    local $/ = undef;
    my $ini = <$fh>;

    my @s = split / ^ ( \[ Profile \d+ \] ) $/mx, $ini;
    shift @s;
    my $i = -1;
    my $p;
    for (@s) {
        # header
        if (not ++$i % 2) {
            $p = $_;
        }
        # body
        else {
            my ($name) = /Name=(.+)/;
            my ($path) = /Path=(.+)/;
            $name or error "Couldn't get name for profile", Y $p;
            $path or error "Couldn't get dir for profile", Y $p;
            $profiles{$name} = "$d/$path";
        }
    }

    return %profiles;
}

sub set_profile_dir {
    my ($pd) = @_;
    $Profile_dir = $pd;
}

timeout( 1000, sub { poll_movies() } );

# Output_dir can be undef
$g->init($Output_dir, { profile_ask => $profile_ask });

exit;

# # #

sub poll_movies {
    $Profile_dir or return 1;

    my $hist = Fish::Youtube::History->new(
        num_movies => 15,
        # can be undef
        profile_dir => $Profile_dir,
    );

    $hist->update;
    my $m = $hist->movies;

    # no undefined element
    if (@$m and not grep { not defined } @$m) {
        $g->set_buf($m);
    }

    return 1;
}

sub error {
    my @s = @_;
    my $e = join ' ', @s, "\n";
    if (Fish::Youtube::Gtk->inited) {
        Fish::Youtube::Gtk::err($e);
    }
    else {
        die $e;
    }
}

sub war {
    my @s = @_;
    warn join ' ', @s, "\n";
}

sub make_tmp_dir {
    my $d = File::Temp->newdir( 'fishtubeXXXX', DIR => $TMP, CLEANUP => 1 );
    # so it doesn't go out of scope
    push @Tmp_dirs, $d;
    $d->dirname;
}

# want prompting for qual and type
# still in event loop -- no enter/exit necessary
sub start_download_sync {

    my $did = shift // die;
    my $mid = shift // die;
    my $url = shift or die;
    my $output_dir = shift or die;

    # one or both are '', meaning prompt
    my $prefq = shift // die;
    my $preft = shift // die;

    # is_tolerant
    my $itaq = shift // die;
    my $itat = shift // die;

    my $msg = {
        did => $did,
        url => $url,
        prefq => $prefq,
        preft => $preft,
        itaq => 1,
        itat => 1,
    };

    return _start_download($msg, 0);
}

sub start_download_async {
    my $did = shift // die;
    my $mid = shift // die;
    my $url = shift or die;
    my $output_file = shift or die;
    my $prefq = shift // die;
    my $preft = shift // die;
    # is_tolerant
    my $itaq = shift // die;
    my $itat = shift // die;

    my $msg = {
        did => $did,
        url => "http://www.youtube.com/watch?v=QARALafdWUI",
        of => $output_file,
    };

    return _start_download($msg, 0);
}

sub _start_download {

    my ($msg, $async) = @_;

    my $tmp_dir = main::make_tmp_dir();
    $msg->{error_file} = $tmp_dir . "/yt-err",

    my $t = 'Fish::Youtube::DownloadThreads';

    my $tid = $t->queue_idle->dequeue;

    return if $tid < 0; # ?

    my $qo = $t->queues_in->{$tid};
    my $qi = $t->queues_out->{$tid};

    my $response;

    # send init msg
    $qo->enqueue($msg);

    # recv: 
    # {error => 1} or available quals.
    $response = $qi->dequeue or warn, return;

    my $e;
    $e = $response->{error} and warn ($e), return;

    if ($async) {
        # We don't care about anything any more, just let it go.
        # This signals caller to start watching.
        return $tid;
    }
    else {

        my @quals = list $response->{quals};

        my $qual = Fish::Youtube::Gtk::list_choice_dialog(\@quals, "Choose quality", {allow_cancel => 1});

        if ($qual) {
            $qo->enqueue( { qual => $qual } );
        }
        else {
            $qo->enqueue( { cancel => 1 });
            return -1;
        }

        # types for this qual
        $response = $qi->dequeue or warn, return;

        my @types = list $response->{types} or warn, return;

        my $type = Fish::Youtube::Gtk::list_choice_dialog(\@types, "Choose format", {allow_cancel => 1});

        if ($qual) {
            $qo->enqueue( { type => $type } );
        }
        else {
            $qo->enqueue( { cancel => 1 });
            return -1;
        }
    }

    $response = $qi->dequeue or warn, return;

    $response->{error} and warn, return;
    $response->{ready} or warn, return;

    # This signals caller to start watching.
    return $tid;
}



sub process_running {
    my ($pid) = @_;
    my $t = Proc::ProcessTable->new->table;
    my @children = grep { 
        $_->{pid} == $pid 
    } @$t;
    return @children ? 1 : 0;
}

sub timeout {
    my ($time, $sub) = @_;
    Glib::Timeout->add($time, $sub );
}

sub watch_movie {
    my ($file) = @_;
    if ( ! -e $file ) {
        $g->err("File '$file' doesn't exist, can't watch.");
        return;
    }
    if ( ! sys_ok qq, which $MOVIE_PLAYER , ) {
        $g->status("Movie player '$MOVIE_PLAYER' doesn't exist.");
        return;
    }

    my $o = $MOVIE_PLAYER_OPTS // '';
    #my $pid = sync_exec qq, $MOVIE_PLAYER $o "$file" ,;
    if (my $pid = fork) {
        D 'child pid', $pid;
    }
    else {
        # not necessary
        setsid();
        # mplayer spawns a new shell and this ends up 'defunct', causing
        # segfault on close?
        exec qq, $MOVIE_PLAYER $o "$file" ,;
    }
}

sub set_output_dir {
    my ($od) = @_;
    $Output_dir = $od or die;
    #D $od;
}

sub check_output_dir {
    my ($od) = @_;
    my $ok = 1;
    $ok = 0, error "Output dir", Y $od, "doesn't exist" unless -d $od;
    $ok = 0, error "Output dir", Y $od, "not writeable" unless -w $od;

    # error won't die if gui already up
    return $ok;
}

sub sanitize_filename {
    my $tr = shift;
    $$tr =~ s/^\s+//;
    $$tr =~ s/\s+$//;
    $$tr =~ s/[\n:!\*<>\`\$]//g;
    
    $$tr =~ s|/|-|g;
    $$tr =~ s|\\|-|g;
    $$tr =~ s/"/'/g;
}
